[
  {
    "doc_id": "Software_design",
    "chunk_id": 0,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_design.txt",
    "start_char": 0,
    "end_char": 1026,
    "text": "Software design\n\nSoftware design is the process of conceptualizing how a software system will work before it is implemented or modified.\nSoftware design also refers to the direct result of the design process – the concepts of how the software will work which may be formally  documented or may be maintained less formally, including via oral tradition.\nThe design process enables a designer to model aspects of a software system before it exists with the intent of making the effort of writing the code more efficiently. Creativity, past experience, a sense of what makes \"good\" software, and a commitment to quality are success factors for a competent design.\nA software design can be compared to an  architected plan for a house. High-level plans represent the totality of the house (e.g., a three-dimensional rendering of the house). Lower-level plans provide guidance for constructing each detail (e.g., the plumbing lay). Similarly, the software design model provides a variety of views of the proposed software solution."
  },
  {
    "doc_id": "Software_design",
    "chunk_id": 1,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_design.txt",
    "start_char": 17,
    "end_char": 1026,
    "text": "Software design is the process of conceptualizing how a software system will work before it is implemented or modified.\nSoftware design also refers to the direct result of the design process – the concepts of how the software will work which may be formally  documented or may be maintained less formally, including via oral tradition.\nThe design process enables a designer to model aspects of a software system before it exists with the intent of making the effort of writing the code more efficiently. Creativity, past experience, a sense of what makes \"good\" software, and a commitment to quality are success factors for a competent design.\nA software design can be compared to an  architected plan for a house. High-level plans represent the totality of the house (e.g., a three-dimensional rendering of the house). Lower-level plans provide guidance for constructing each detail (e.g., the plumbing lay). Similarly, the software design model provides a variety of views of the proposed software solution."
  },
  {
    "doc_id": "Software_design",
    "chunk_id": 2,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_design.txt",
    "start_char": 2039,
    "end_char": 2823,
    "text": "Part of the overall process\nIn terms of the waterfall development process, software design is the activity that occurs after requirements analysis and before coding. Requirements analysis determines what the system needs to do without determining how it will do it, and thus, multiple designs can be imagined that satisfy the requirements. The design can be created while coding, without a plan or requirements analysis, but for more complex projects this is less feasible. Completing a design prior to coding allows for multidisciplinary designers and subject-matter experts to collaborate with programmers to produce software that is useful and technically sound.\nSometimes, a simulation or prototype is created to model the system in an effort to determine a valid and good design."
  },
  {
    "doc_id": "Software_design",
    "chunk_id": 3,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_design.txt",
    "start_char": 2825,
    "end_char": 3867,
    "text": "Code as design\nA common point of confusion with the term design in software is that the process applies at multiple levels of abstraction such as a high-level software architecture and lower-level components, functions and algorithms. A relatively formal process may occur at high levels of abstraction but at lower levels, the design process is almost always less formal where the only artifact of design may be the code itself. To the extent that this is true, software design refers to the design of the design.  Edsger W. Dijkstra referred to this layering of semantic levels as the \"radical novelty\" of computer programming, and Donald Knuth used his experience writing TeX to describe the futility of attempting to design a program prior to implementing it:\n\nTEX would have been a complete failure if I had merely specified it and not participated fully in its initial implementation. The process of implementation constantly led me to unanticipated questions and to new insights about how the original specifications could be improved."
  },
  {
    "doc_id": "Software_design",
    "chunk_id": 4,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_design.txt",
    "start_char": 3869,
    "end_char": 4833,
    "text": "Artifacts\nA design process may include the production of art Software design documentation such as flow chart, use case, Pseudocode, Unified Modeling Language model and other Fundamental modeling concepts. For  user centered software, design may involve user experience design yielding a storyboard to help determine those specifications. Documentation may be reviewed to allow constraints, specifications and even requirements to be adjusted prior to coding.\n\nIterative Design\nSoftware systems inherently deal with uncertainties, and the size of software components can significantly influence a system's outcomes, both positively and negatively. Neal Ford and Mark Richards propose an iterative approach to address the challenge of identifying and right-sizing components. This method emphasizes continuous refinement as teams develop a more nuanced understanding of system behavior and requirements. \nThe approach typically involves a cycle with several stages:"
  },
  {
    "doc_id": "Software_design",
    "chunk_id": 5,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_design.txt",
    "start_char": 4835,
    "end_char": 5781,
    "text": "A high-level partitioning strategy is established, often categorized as technical or domain-based. Guidelines for the smallest meaningful deployable unit, referred to as \"quanta,\" are defined. While these foundational decisions are made early, they may be revisited later in the cycle if necessary.\nInitial components are identified based on the established strategy.\nRequirements are assigned to the identified components.\nThe roles and responsibilities of each component are analyzed to ensure clarity and minimize overlap.\nArchitectural characteristics, such as scalability, fault tolerance, and maintainability, are evaluated.\nComponents may be restructured based on feedback from development teams.\nThis cycle serves as a general framework and can be adapted to different domains.\n\nDesign principles\nDesign principles enable a software engineer to navigate the design process. Davis suggested principles which have been refined over time as:"
  },
  {
    "doc_id": "Software_design",
    "chunk_id": 6,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_design.txt",
    "start_char": 5783,
    "end_char": 6870,
    "text": "The design process should not suffer from \"tunnel vision\"\nA good designer should consider alternative approaches, judging each based on the requirements of the problem, the resources available to do the job.\nThe design should be traceable to the analysis model\nBecause a single element of the design model can often be traced back to multiple requirements, it is necessary to have a means for tracking how requirements have been satisfied by the design model.\nThe design should not reinvent the wheel\nSystems are constructed using a set of design patterns, many of which have likely been encountered before. These patterns should always be chosen as an alternative to reinvention. Time is short and resources are limited; design time should be invested in representing (truly new) ideas by integrating patterns that already exist (when applicable).\nThe design should \"minimize the intellectual distance\" between the software and the problem as it exists in the real world\nThat is, the structure of the software design should, whenever possible, mimic the structure of the problem domain."
  },
  {
    "doc_id": "Software_design",
    "chunk_id": 7,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_design.txt",
    "start_char": 6755,
    "end_char": 7679,
    "text": "That is, the structure of the software design should, whenever possible, mimic the structure of the problem domain.\nThe design should exhibit uniformity and integration\nA design is uniform if it appears fully coherent. In order to achieve this outcome, rules of style and format should be defined for a design team before design work begins. A design is integrated if care is taken in defining interfaces between design components.\nThe design should be structured to accommodate change\nThe design concepts discussed in the next section enable a design to achieve this principle.\nThe design should be structured to degrade gently, even when aberrant data, events, or operating conditions are encountered\nWell-designed software should never \"bomb\"; it should be designed to accommodate unusual circumstances, and if it must terminate processing, it should do so in a graceful manner.\nDesign is not coding, coding is not design"
  },
  {
    "doc_id": "Software_design",
    "chunk_id": 8,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_design.txt",
    "start_char": 7637,
    "end_char": 8574,
    "text": "Design is not coding, coding is not design\nEven when detailed procedural designs are created for program components, the level of abstraction of the design model is higher than the source code. The only design decisions made at the coding level should address the small implementation details that enable the procedural design to be coded.\nThe design should be assessed for quality as it is being created, not after the fact\nA variety of design concepts and design measures are available to assist the designer in assessing quality throughout the development process.\nThe design should be reviewed to minimize conceptual (semantic) errors\nThere is sometimes a tendency to focus on minutiae when the design is reviewed, missing the forest for the trees. A design team should ensure that major conceptual elements of the design (omissions, ambiguity, inconsistency) have been addressed before worrying about the syntax of the design model."
  },
  {
    "doc_id": "Software_design",
    "chunk_id": 9,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_design.txt",
    "start_char": 8576,
    "end_char": 8723,
    "text": "Design concepts\nDesign concepts provide a designer with a foundation from which more sophisticated methods can be applied. Design concepts include:"
  },
  {
    "doc_id": "Software_design",
    "chunk_id": 10,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_design.txt",
    "start_char": 8725,
    "end_char": 9702,
    "text": "Abstraction\nReducing the information content of a concept or an observable phenomenon, typically to retain only information that is relevant for a particular purpose. It is an act of Representing essential features without including the background details or explanations.\nArchitecture\nThe overall structure of the software and the ways in which that structure provides conceptual integrity for a system. Good software architecture will yield a good return on investment with respect to the desired outcome of the project, e.g. in terms of performance, quality, schedule and cost.\nControl hierarchy\nA program structure that represents the organization of a program component and implies a hierarchy of control.\nData structure\nRepresenting the logical relationship between elements of data.\nDesign pattern\nA designer may identify a design aspect of the system that has solved in the past. The reuse of such patterns can increase software development velocity.\nInformation hiding"
  },
  {
    "doc_id": "Software_design",
    "chunk_id": 11,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_design.txt",
    "start_char": 9515,
    "end_char": 10369,
    "text": "Design pattern\nA designer may identify a design aspect of the system that has solved in the past. The reuse of such patterns can increase software development velocity.\nInformation hiding\nModules should be specified and designed so that information contained within a module is inaccessible to other modules that have no need for such information.\nModularity\nDividing the solution into parts (modules).\n Refinement\nThe process of elaboration. A hierarchy is developed by decomposing a macroscopic statement of function in a step-wise fashion until programming language statements are reached. In each step, one or several instructions of a given program are decomposed into more detailed instructions. Abstraction and Refinement are complementary concepts.\nSoftware procedure\nFocuses on the processing of each module individually.\nStructural partitioning"
  },
  {
    "doc_id": "Software_design",
    "chunk_id": 12,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_design.txt",
    "start_char": 10272,
    "end_char": 10887,
    "text": "Software procedure\nFocuses on the processing of each module individually.\nStructural partitioning\nThe program structure can be divided horizontally and vertically. Horizontal partitions define separate branches of modular hierarchy for each major program function. Vertical partitioning suggests that control and work should be distributed top-down in the program structure.\nGrady Booch mentions abstraction, encapsulation, modularization, and hierarchy as fundamental software design principles. The phrase principles of hierarchy, abstraction, modularization, and encapsulation (PHAME) refers to these principles."
  },
  {
    "doc_id": "Software_design",
    "chunk_id": 13,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_design.txt",
    "start_char": 10889,
    "end_char": 11102,
    "text": "Design considerations\nThere are many aspects to consider in the design of software. The importance of each should reflect the goals and expectations to which the software is being created. Notable aspects include:"
  },
  {
    "doc_id": "Software_design",
    "chunk_id": 14,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_design.txt",
    "start_char": 11104,
    "end_char": 12144,
    "text": "Compatibility\nThe software is able to operate with other products that are designed for interoperability with another product.  For example, a piece of software may be backward-compatible with an older version of itself.\nExtensibility\nNew capabilities can be added to the software without major changes to the underlying architecture.\nFault-tolerance\nThe software is resistant to and able to recover from component failure.\nMaintainability\nA measure of how easily bug fixes or functional modifications can be accomplished. High maintainability can be the product of modularity and extensibility.\nModularity\nThe resulting software comprises well defined, independent components which leads to better maintainability. The components could be then implemented and tested in isolation before being integrated to form a desired software system. This allows division of work in a software development project.\nOverhead\nHow the consumption of resources required for overhead impacts the resources needed to achieve system requirements.\nPerformance"
  },
  {
    "doc_id": "Software_design",
    "chunk_id": 15,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_design.txt",
    "start_char": 12008,
    "end_char": 12810,
    "text": "Overhead\nHow the consumption of resources required for overhead impacts the resources needed to achieve system requirements.\nPerformance\nThe software performs its tasks within a time-frame that is acceptable for the user, and does not require too much memory.\nPortability\nThe software should be usable across a number of different conditions and environments.\nReliability\nThe software is able to perform a required function under stated conditions for a specified period of time.\nReusability\nThe ability to use some or all of the aspects of the preexisting software in other projects with little to no modification.\nRobustness\nThe software is able to operate under stress or tolerate unpredictable or invalid input.  For example, it can be designed with resilience to low memory conditions.\nScalability"
  },
  {
    "doc_id": "Software_design",
    "chunk_id": 16,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_design.txt",
    "start_char": 12624,
    "end_char": 13413,
    "text": "Robustness\nThe software is able to operate under stress or tolerate unpredictable or invalid input.  For example, it can be designed with resilience to low memory conditions.\nScalability\nThe software adapts well to increasing data or added features or number of users. According to Marc Brooker: \"a system is scalable in the range where marginal cost of additional workload is nearly constant.\" Serverless technologies fit this definition but you need to consider total cost of ownership not just the infra cost.\nSecurity\nThe software is able to withstand and resist hostile acts and influences.\nUsability\nThe software user interface must be usable for its target user/audience. Default values for the parameters must be chosen so that they are a good choice for the majority of the users."
  },
  {
    "doc_id": "Software_design",
    "chunk_id": 17,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_design.txt",
    "start_char": 13415,
    "end_char": 13769,
    "text": "Modeling language\nA modeling language can be used to express information, knowledge or systems in a structure that is defined by a consistent set of rules. These rules are used for interpretation of the components within the structure. A modeling language can be graphical or textual. Examples of graphical modeling languages for software design include:"
  },
  {
    "doc_id": "Software_design",
    "chunk_id": 18,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_design.txt",
    "start_char": 13771,
    "end_char": 14700,
    "text": "Architecture description language (ADL)\nA language used to describe and represent the software architecture of a software system.\nBusiness Process Modeling Notation (BPMN)\nAn example of a Process Modeling language.\nEXPRESS and EXPRESS-G (ISO 10303-11)\nAn international standard general-purpose data modeling language.\nExtended Enterprise Modeling Language (EEML)\nCommonly used for business process modeling across a number of layers.\nFlowchart\nSchematic representations of algorithms or other step-wise processes.\nFundamental Modeling Concepts (FMC)\nA modeling language for software-intensive systems.\nIDEF\nA family of modeling languages, the most notable of which include IDEF0 for functional modeling, IDEF1X for information modeling, and IDEF5 for modeling ontologies.\nJackson Structured Programming (JSP)\nA method for structured programming based on correspondences between data stream structure and program structure.\nLePUS3"
  },
  {
    "doc_id": "Software_design",
    "chunk_id": 19,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_design.txt",
    "start_char": 14543,
    "end_char": 15451,
    "text": "Jackson Structured Programming (JSP)\nA method for structured programming based on correspondences between data stream structure and program structure.\nLePUS3\nAn object-oriented visual Design Description Language and a formal specification language that is suitable primarily for modeling large object-oriented (Java, C++, C#) programs and design patterns.\nUnified Modeling Language (UML)\nA general modeling language to describe software both structurally and behaviorally.  It has a graphical notation and allows for extension with a Profile (UML).\nAlloy (specification language)\nA general purpose specification language for expressing complex structural constraints and behavior in a software system. It provides a concise language base on first-order relational logic.\nSystems Modeling Language (SysML)\nA general-purpose modeling language for systems engineering.\nService-oriented modeling framework (SOMF)"
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 0,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 0,
    "end_char": 664,
    "text": "Software engineering\n\nSoftware engineering is a branch of both computer science and engineering focused on designing, developing, testing, and maintaining software applications. It involves applying engineering principles and computer programming expertise to develop software systems that meet user needs.\nThe terms programmer and coder overlap software engineer, but they imply only the construction aspect of a typical software engineer workload.\nA software engineer applies a software development process, which involves defining, implementing, testing, managing, and maintaining software systems, as well as developing the software development process itself."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 1,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 22,
    "end_char": 664,
    "text": "Software engineering is a branch of both computer science and engineering focused on designing, developing, testing, and maintaining software applications. It involves applying engineering principles and computer programming expertise to develop software systems that meet user needs.\nThe terms programmer and coder overlap software engineer, but they imply only the construction aspect of a typical software engineer workload.\nA software engineer applies a software development process, which involves defining, implementing, testing, managing, and maintaining software systems, as well as developing the software development process itself."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 2,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 1310,
    "end_char": 1920,
    "text": "History\nBeginning in the 1960s, software engineering was recognized as a separate field of engineering.\nThe development of software engineering was seen as a struggle. Problems included software that was over budget, exceeded deadlines, required extensive debugging and maintenance, and unsuccessfully met the needs of consumers or was never even completed.\nIn 1968, NATO organized the first conference on software engineering, which addressed emerging challenges in software development. The event played a key role in formalizing guidelines and best practices for creating reliable and maintainable software."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 3,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 1921,
    "end_char": 3006,
    "text": "The origins of the term software engineering have been attributed to various sources. The term appeared in a list of services offered by companies in the June 1965 issue of \"Computers and Automation\" and was used more formally in the August 1966 issue of Communications of the ACM (Volume 9, number 8) in \"President's Letter to the ACM Membership\" by Anthony A. Oettinger. It is also associated with the title of a NATO conference in 1968 by Professor Friedrich L. Bauer. Margaret Hamilton described the discipline of \"software engineering\" during the Apollo missions to give what they were doing legitimacy. At the time, there was perceived to be a \"software crisis\". The 40th International Conference on Software Engineering (ICSE 2018) celebrates 50 years of \"Software Engineering\" with the Plenary Sessions' keynotes of Frederick Brooks and Margaret Hamilton.\nIn 1984, the Software Engineering Institute (SEI) was established as a federally funded research and development center headquartered on the campus of Carnegie Mellon University in Pittsburgh, Pennsylvania, United States."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 4,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 3007,
    "end_char": 3897,
    "text": "Watts Humphrey founded the SEI Software Process Program, aimed at understanding and managing the software engineering process. The Process Maturity Levels introduced became the Capability Maturity Model Integration for Development (CMMI-DEV), which defined how the US Government evaluates the abilities of a software development team.\nModern, generally accepted best practices for software engineering have been collected by the ISO/IEC JTC 1/SC 7 subcommittee and published as the Software Engineering Body of Knowledge (SWEBOK). Software engineering is considered one of the major computing disciplines.\nIn modern systems, where concepts such as Edge Computing, Internet of Things and Cyber-physical Systems are prevalent, software is a critical factor. Thus, software engineering is closely related to the Systems Engineering discipline. The Systems Engineering Body of Knowledge claims:"
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 5,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 3899,
    "end_char": 4840,
    "text": "Software is prominent in most modern systems architectures and is often the primary means for integrating complex system components. Software engineering and systems engineering are not merely related disciplines; they are intimately intertwined....Good systems engineering is a key factor in enabling good software engineering.\n\nTerminology\nDefinition\nNotable definitions of software engineering include:\n\n\"The systematic application of scientific and technological knowledge, methods, and experience to the design, implementation, testing, and documentation of software.\"—The Bureau of Labor Statistics—IEEE Systems and software engineering – Vocabulary\n\"The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software.\"—IEEE Standard Glossary of Software Engineering Terminology\n\"An engineering discipline concerned with all aspects of software production.\" — Ian Sommerville"
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 6,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 4843,
    "end_char": 5477,
    "text": "\"The establishment and use of sound engineering principles in order to economically obtain software that is reliable and works efficiently on real machines.\"—Fritz Bauer\n\"A branch of computer science that deals with the design, implementation, and maintenance of complex computer programs.\"—Merriam-Webster\n\"'Software engineering' encompasses not just the act of writing code, but all of the tools and processes an organization uses to build and maintain that code over time. [...] Software engineering can be thought of as 'programming integrated over time.'\"—Software Engineering at Google\nThe term has also been used less formally:"
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 7,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 5479,
    "end_char": 6521,
    "text": "as the informal contemporary term for the broad range of activities that were formerly called computer programming and systems analysis\nas the broad term for all aspects of the practice of computer programming, as opposed to the theory of computer programming, which is formally studied as a sub-discipline of computer science\nas the term embodying the advocacy of a specific approach to computer programming, one that urges that it be treated as an engineering discipline rather than an art or a craft, and advocates the codification of recommended practices\n\nSuitability\nIndividual commentators have disagreed sharply on how to define software engineering or its legitimacy as an engineering discipline. David Parnas has said that software engineering is, in fact, a form of engineering. Steve McConnell has said that it is not, but that it should be. Donald Knuth has said that programming is an art and a science. Edsger W. Dijkstra claimed that the terms software engineering and software engineer have been misused in the United States."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 8,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 6523,
    "end_char": 7559,
    "text": "Workload\nRequirements analysis\nRequirements engineering is about elicitation, analysis, specification, and validation of requirements for software. Software requirements can be functional, non-functional or domain.\nFunctional requirements describe expected behaviors (i.e. outputs). Non-functional requirements specify issues like portability, security, maintainability, reliability, scalability, performance, reusability, and flexibility. They are classified into the following types: interface constraints, performance constraints (such as response time, security, storage space, etc.), operating constraints, life cycle constraints (maintainability, portability, etc.), and economic constraints. Knowledge of how the system or software works is needed when it comes to specifying non-functional requirements. Domain requirements have to do with the characteristic of a certain category or domain of projects.\n\nDesign\nSoftware design is the process of making high-level plans for the software. Design is sometimes divided into levels:"
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 9,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 7436,
    "end_char": 8165,
    "text": "Design\nSoftware design is the process of making high-level plans for the software. Design is sometimes divided into levels:\n\nInterface design plans the interaction between a system and its environment as well as the inner workings of the system.\nArchitectural design plans the major components of a system, including their responsibilities, properties, and interfaces between them.\nDetailed design plans internal elements, including their properties, relationships, algorithms and data structures.\n\nConstruction\nSoftware construction typically involves programming (a.k.a. coding), unit testing, integration testing, and debugging so as to implement the design.\"Software testing is related to, but different from, ... debugging\"."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 10,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 8167,
    "end_char": 9001,
    "text": "Testing\nSoftware testing is an empirical, technical investigation conducted to provide stakeholders with information about the quality of the software under test. Software testing can be viewed as a risk based activity. \nWhen described separately from construction, testing typically is performed by test engineers or quality assurance instead of the programmers who wrote it. It is performed at the system level and is considered an aspect of software quality. The testers' goals during the testing process are to minimize the overall number of tests to a manageable set and make well-informed decisions regarding which risks should be prioritized for testing and which can wait.\n\nProgram analysis\nProgram analysis is the process of analyzing computer programs with respect to an aspect such as performance, robustness, and security."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 11,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 8849,
    "end_char": 9293,
    "text": "Program analysis\nProgram analysis is the process of analyzing computer programs with respect to an aspect such as performance, robustness, and security.\n\nMaintenance\nSoftware maintenance refers to supporting the software after release. It may include but is not limited to: error correction, optimization, deletion of unused and discarded features, and enhancement of existing features.\nUsually, maintenance takes up 40% to 80% of project cost."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 12,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 9295,
    "end_char": 10272,
    "text": "Education\nKnowledge of computer programming is a prerequisite for becoming a software engineer. In 2004, the IEEE Computer Society produced the SWEBOK, which has been published as ISO/IEC Technical Report 1979:2005, describing the body of knowledge that they recommend to be mastered by a graduate software engineer with four years of experience.\nMany software engineers enter the profession by obtaining a university degree or training at a vocational school. One standard international curriculum for undergraduate software engineering degrees was defined by the Joint Task Force on Computing Curricula of the IEEE Computer Society and the Association for Computing Machinery, and updated in 2014. A number of universities have Software Engineering degree programs; as of 2010, there were 244 Campus Bachelor of Software Engineering programs, 70 Online programs, 230 Masters-level programs, 41 Doctorate-level programs, and 69 Certificate-level programs in the United States."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 13,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 10273,
    "end_char": 10610,
    "text": "In addition to university education, many companies sponsor internships for students wishing to pursue careers in information technology. These internships can introduce the student to real-world tasks that typical software engineers encounter every day. Similar experience can be gained through military service in software engineering."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 14,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 10612,
    "end_char": 11276,
    "text": "Software engineering degree programs\nA small but growing number of practitioners have software engineering degrees. In 1987, the Department of Computing at Imperial College London introduced the first three-year software engineering bachelor's degree in the world; in the following year, the University of Sheffield established a similar program. In 1996, the Rochester Institute of Technology established the first software engineering bachelor's degree program in the United States; however, it did not obtain ABET accreditation until 2003, the same year as Rice University, Clarkson University, Milwaukee School of Engineering, and Mississippi State University."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 15,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 11278,
    "end_char": 12147,
    "text": "Since then, software engineering undergraduate degrees have been established at many universities. A standard international curriculum for undergraduate software engineering degrees, SE2004, was defined by a steering committee between 2001 and 2004 with funding from the Association for Computing Machinery and the IEEE Computer Society. As of 2004, about 50 universities in the U.S. offer software engineering degrees, which teach both computer science and engineering principles and practices. The first software engineering master's degree was established at Seattle University in 1979. Since then, graduate software engineering degrees have been made available from many more universities. Likewise in Canada, the Canadian Engineering Accreditation Board (CEAB) of the Canadian Council of Professional Engineers has recognized several software engineering programs."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 16,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 12148,
    "end_char": 12837,
    "text": "Additionally, many online advanced degrees in Software Engineering have appeared such as the Master of Science in Software Engineering (MSE) degree offered through the Computer Science and Engineering Department at California State University, Fullerton. Steve McConnell opines that because most universities teach computer science rather than software engineering, there is a shortage of true software engineers. ETS (École de technologie supérieure) University and UQAM (Université du Québec à Montréal) were mandated by IEEE to develop the Software Engineering Body of Knowledge (SWEBOK), which has become an ISO standard describing the body of knowledge covered by a software engineer."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 17,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 12839,
    "end_char": 13834,
    "text": "Profession\nLegal requirements for the licensing or certification of professional software engineers vary around the world. In the UK, there is no licensing or legal requirement to assume or use the job title Software Engineer. In some areas of Canada, such as Alberta, British Columbia, Ontario, and Quebec, software engineers can hold the Professional Engineer (P.Eng) designation and/or the Information Systems Professional (I.S.P.) designation. In Europe, Software Engineers can obtain the European Engineer (EUR ING) professional title. Software Engineers can also become professionally qualified as a Chartered Engineer through the British Computer Society.\nIn the United States, the NCEES began offering a Professional Engineer exam for Software Engineering in 2013, thereby allowing Software Engineers to be licensed and recognized. NCEES ended the exam after April 2019 due to lack of participation. Mandatory licensing is currently still largely debated, and perceived as controversial."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 18,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 13835,
    "end_char": 14304,
    "text": "The IEEE Computer Society and the ACM, the two main US-based professional organizations of software engineering, publish guides to the profession of software engineering. The IEEE's Guide to the Software Engineering Body of Knowledge – 2004 Version, or SWEBOK, defines the field and describes the knowledge the IEEE expects a practicing software engineer to have. The most current version is SWEBOK v4. The IEEE also promulgates a \"Software Engineering Code of Ethics\"."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 19,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 14306,
    "end_char": 15264,
    "text": "Employment\nThere are an estimated 26.9 million professional software engineers in the world as of 2022, up from 21 million in 2016.\nMany software engineers work as employees or contractors. Software engineers work with businesses, government agencies (civilian or military), and non-profit organizations. Some software engineers work for themselves as freelancers. Some organizations have specialists to perform each of the tasks in the software development process. Other organizations require software engineers to do many or all of them. In large projects, people may specialize in only one role. In small projects, people may fill several or all roles at the same time. Many companies hire interns, often university or college students during a summer break, or externships. Specializations include analysts, architects, developers, testers, technical support, middleware analysts, project managers, software product managers, educators, and researchers."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 20,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 15265,
    "end_char": 15760,
    "text": "Most software engineers and programmers work 40 hours a week, but about 15 percent of software engineers and 11 percent of programmers worked more than 50 hours a week in 2008. Potential injuries in these occupations are possible because like other workers who spend long periods sitting in front of a computer terminal typing at a keyboard, engineers and programmers are susceptible to eyestrain, back discomfort, Thrombosis, Obesity, and hand and wrist problems such as carpal tunnel syndrome."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 21,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 15762,
    "end_char": 15775,
    "text": "United States"
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 22,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 15776,
    "end_char": 16875,
    "text": "The U. S. Bureau of Labor Statistics (BLS) counted 1,365,500 software developers holding jobs in the U.S. in 2018. Due to its relative newness as a field of study, formal education in software engineering is often taught as part of a computer science curriculum, and many software engineers hold computer science degrees. The BLS estimates 2024 to 2034 the growth for software engineers is 15% which is lesser than their prediction from 2023 to 2033 that computer software engineering would increase by 17%. This is down from the 2022 to 2032 BLS estimate of 25% for software engineering. And, is further down from their 30% 2010 to 2020 BLS estimate. Due to this trend, job growth may not be as fast as during the last decade, as jobs that would have gone to computer software engineers in the United States would instead be outsourced to computer software engineers in countries such as India and other foreign countries. In addition, the BLS Job Outlook for Computer Programmers, the U.S. Bureau of Labor Statistics (BLS) Occupational Outlook predicts a decline of -7 percent from 2016 to 2026, a"
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 23,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 16657,
    "end_char": 17701,
    "text": "such as India and other foreign countries. In addition, the BLS Job Outlook for Computer Programmers, the U.S. Bureau of Labor Statistics (BLS) Occupational Outlook predicts a decline of -7 percent from 2016 to 2026, a further decline of -9 percent from 2019 to 2029, a decline of -10 percent from 2021 to 2031. and then a decline of -11 percent from 2022 to 2032. Currently their prediction for 2024 to 2034 is a decline of -6 percent. Since computer programming can be done from anywhere in the world, companies sometimes hire programmers in countries where wages are lower. Furthermore, the ratio of women in many software fields has also been declining over the years as compared to other engineering fields. Then there is the additional concern that recent advances in Artificial Intelligence might impact the demand for future generations of Software Engineers. However, this trend may change or slow in the future as many current software engineers in the U.S. market flee the profession or age out of the market in the next few decades."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 24,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 17703,
    "end_char": 18674,
    "text": "Certification\nThe Software Engineering Institute offers certifications on specific topics like security, process improvement and software architecture. IBM, Microsoft and other companies also sponsor their own certification examinations. Many IT certification programs are oriented toward specific technologies, and managed by the vendors of these technologies. These certification programs are tailored to the institutions that would employ people who use these technologies.\nBroader certification of general software engineering skills is available through various professional societies. As of 2006, the IEEE had certified over 575 software professionals as a Certified Software Development Professional (CSDP). In 2008 they added an entry-level certification known as the Certified Software Development Associate (CSDA). The ACM and the IEEE Computer Society together examined the possibility of licensing of software engineers as Professional Engineers in the 1990s,"
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 25,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 18675,
    "end_char": 18904,
    "text": "but eventually decided that such licensing was inappropriate for the professional industrial practice of software engineering. John C. Knight and Nancy G. Leveson presented a more balanced analysis of the licensing issue in 2002."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 26,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 18905,
    "end_char": 20000,
    "text": "In the U.K. the British Computer Society has developed a legally recognized professional certification called Chartered IT Professional (CITP), available to fully qualified members (MBCS). Software engineers may be eligible for membership of the British Computer Society or Institution of Engineering and Technology and so qualify to be considered for Chartered Engineer status through either of those institutions. In Canada the Canadian Information Processing Society has developed a legally recognized professional certification called Information Systems Professional (ISP). In Ontario, Canada, Software Engineers who graduate from a Canadian Engineering Accreditation Board (CEAB) accredited program, successfully complete PEO's (Professional Engineers Ontario) Professional Practice Examination (PPE) and have at least 48 months of acceptable engineering experience are eligible to be licensed through the Professional Engineers Ontario and can become Professional Engineers P.Eng. The PEO does not recognize any online or distance education however; and does not consider Computer Science"
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 27,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 19781,
    "end_char": 20440,
    "text": "eligible to be licensed through the Professional Engineers Ontario and can become Professional Engineers P.Eng. The PEO does not recognize any online or distance education however; and does not consider Computer Science programs to be equivalent to software engineering programs despite the tremendous overlap between the two. This has sparked controversy and a certification war. It has also held the number of P.Eng holders for the profession exceptionally low. The vast majority of working professionals in the field hold a degree in CS, not SE. Given the difficult certification path for holders of non-SE degrees, most never bother to pursue the license."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 28,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 20442,
    "end_char": 20465,
    "text": "Impact of globalization"
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 29,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 20466,
    "end_char": 21564,
    "text": "The initial impact of outsourcing, and the relatively lower cost of international human resources in developing third world countries led to a massive migration of software development activities from corporations in North America and Europe to India and later: China, Russia, and other developing countries. This approach had some flaws, mainly the distance / time zone difference that prevented human interaction between clients and developers and the massive job transfer. This had a negative impact on many aspects of the software engineering profession. For example, some students in the developed world avoid education related to software engineering because of the fear of offshore outsourcing (importing software products or services from other countries) and of being displaced by foreign visa workers. Additionally, the glut of high-tech workers has led to a wider adoption of the 996 working hour system and ‘007’ schedules as the expected work load. Although statistics do not currently show a threat to software engineering itself; a related career, computer programming does appear to"
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 30,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 21350,
    "end_char": 22087,
    "text": "of the 996 working hour system and ‘007’ schedules as the expected work load. Although statistics do not currently show a threat to software engineering itself; a related career, computer programming does appear to have been affected. Nevertheless, the ability to smartly leverage offshore and near-shore resources via the follow-the-sun workflow has improved the overall operational capability of many organizations. When North Americans leave work, Asians are just arriving to work. When Asians are leaving work, Europeans arrive to work. This provides a continuous ability to have human oversight on business-critical processes 24 hours per day, without paying overtime compensation or disrupting a key human resource, sleep patterns."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 31,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 22088,
    "end_char": 22817,
    "text": "While global outsourcing has several advantages, global – and generally distributed – development can run into serious difficulties resulting from the distance between developers. This is due to the key elements of this type of distance that have been identified as geographical, temporal, cultural and communication (that includes the use of different languages and dialects of English in different locations). Research has been carried out in the area of global software development over the last 15 years and an extensive body of relevant work published that highlights the benefits and problems associated with the complex activity. As with other aspects of software engineering research is ongoing in this and related areas."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 32,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 22819,
    "end_char": 23808,
    "text": "Prizes\nThere are various prizes in the field of software engineering:\n\nACM-AAAI Allen Newell Award- USA. Awarded to career contributions that have breadth within computer science, or that bridge computer science and other disciplines.\nBCS Lovelace Medal. Awarded to individuals who have made outstanding contributions to the understanding or advancement of computing.\nACM SIGSOFT Outstanding Research Award, selected for individual(s) who have made \"significant and lasting research contributions to the theory or practice of software engineering.\"\nMore ACM SIGSOFT Awards.\nThe Codie award, a yearly award issued by the Software and Information Industry Association for excellence in software development within the software industry.\nHarlan Mills Award for \"contributions to the theory and practice of the information sciences, focused on software engineering\".\nICSE Most Influential Paper Award.\nJolt Award, also for the software industry.\nStevens Award given in memory of Wayne Stevens."
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 33,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 23810,
    "end_char": 24751,
    "text": "Criticism\nSome call for licensing, certification and codified bodies of knowledge as mechanisms for spreading the engineering knowledge and maturing the field.\nSome claim that the concept of software engineering is so new that it is rarely understood, and it is widely misinterpreted, including in software engineering textbooks, papers, and among the communities of programmers and crafters.\nSome claim that a core issue with software engineering is that its approaches are not empirical enough because a real-world validation of approaches is usually absent, or very limited and hence software engineering is often misinterpreted as feasible only in a \"theoretical environment.\"\nEdsger Dijkstra, a founder of many of the concepts in software development today, rejected the idea of \"software engineering\" up until his death in 2002, arguing that those terms were poor analogies for what he called the \"radical novelty\" of computer science:"
  },
  {
    "doc_id": "Software_engineering",
    "chunk_id": 34,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_engineering.txt",
    "start_char": 24753,
    "end_char": 25317,
    "text": "A number of these phenomena have been bundled under the name \"Software Engineering\". As economics is known as \"The Miserable Science\", software engineering should be known as \"The Doomed Discipline\", doomed because it cannot even approach its goal since its goal is self-contradictory. Software engineering, of course, presents itself as another worthy cause, but that is eyewash: if you carefully read its literature and analyse what its devotees actually do, you will discover that software engineering has accepted as its charter \"How to program if you cannot.\""
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 0,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 0,
    "end_char": 16,
    "text": "Software testing"
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 1,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 18,
    "end_char": 1091,
    "text": "Software testing is the act of checking whether software meets its intended objectives and satisfies expectations.\nSoftware testing can provide objective, independent information about the quality of software and the risk of its failure to a user or sponsor or any other stakeholder.\nSoftware testing can determine the correctness of software for specific scenarios but cannot determine correctness for all scenarios. It cannot find all bugs.\nBased on the criteria for measuring correctness from an oracle, software testing employs principles and mechanisms that might recognize a problem. Examples of oracles include specifications, contracts, comparable products, past versions of the same product, inferences about intended or expected purpose, user or customer expectations, relevant standards, and applicable laws.\nSoftware testing can be functional or non-functional in nature.\nSoftware testing is often dynamic in nature; running the software to verify actual output matches expected. It can also be static in nature; reviewing code and its associated documentation."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 2,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 902,
    "end_char": 1532,
    "text": "Software testing is often dynamic in nature; running the software to verify actual output matches expected. It can also be static in nature; reviewing code and its associated documentation.\nSoftware testing is often used to answer the question: Does the software do what it is supposed to do and what it needs to do?\nInformation learned from software testing may be used to improve the process by which software is developed.\nA commonly suggested approach to automated testing is the \"test pyramid,\" wherein most of the tests are unit tests, followed by a smaller set of integration tests and finally a few end-to-end (e2e) tests."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 3,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 1534,
    "end_char": 2607,
    "text": "Software testing is the act of checking whether software meets its intended objectives and satisfies expectations.\nSoftware testing can provide objective, independent information about the quality of software and the risk of its failure to a user or sponsor or any other stakeholder.\nSoftware testing can determine the correctness of software for specific scenarios but cannot determine correctness for all scenarios. It cannot find all bugs.\nBased on the criteria for measuring correctness from an oracle, software testing employs principles and mechanisms that might recognize a problem. Examples of oracles include specifications, contracts, comparable products, past versions of the same product, inferences about intended or expected purpose, user or customer expectations, relevant standards, and applicable laws.\nSoftware testing can be functional or non-functional in nature.\nSoftware testing is often dynamic in nature; running the software to verify actual output matches expected. It can also be static in nature; reviewing code and its associated documentation."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 4,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 2418,
    "end_char": 3048,
    "text": "Software testing is often dynamic in nature; running the software to verify actual output matches expected. It can also be static in nature; reviewing code and its associated documentation.\nSoftware testing is often used to answer the question: Does the software do what it is supposed to do and what it needs to do?\nInformation learned from software testing may be used to improve the process by which software is developed.\nA commonly suggested approach to automated testing is the \"test pyramid,\" wherein most of the tests are unit tests, followed by a smaller set of integration tests and finally a few end-to-end (e2e) tests."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 5,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 3050,
    "end_char": 3388,
    "text": "Economics\nA study conducted by NIST in 2002 reported that software bugs cost the U.S. economy $59.5 billion annually. More than a third of this cost could be avoided if better software testing was performed.\nOutsourcing software testing because of costs is very common, with China, the Philippines, and India being preferred destinations."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 6,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 3390,
    "end_char": 4372,
    "text": "History\nGlenford J. Myers initially introduced the separation of debugging from testing in 1979. Although his attention was on breakage testing (\"A successful test case is one that detects an as-yet undiscovered error.\"), it illustrated the desire of the software engineering community to separate fundamental development activities, such as debugging, from that of verification.\nSoftware testing typically includes handling software bugs – a defect in the code that causes an undesirable result. Bugs generally slow testing progress and involve programmer assistance to debug and fix.\nNot all defects cause a failure. For example, a defect in dead code will not be considered a failure.\nA defect that does not cause failure at one point in time may lead to failure later due to environmental changes. Examples of environment change include running on new computer hardware, changes in data, and interacting with different software.\n\nGoals\nSoftware testing is typically goal driven."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 7,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 4324,
    "end_char": 5263,
    "text": "Goals\nSoftware testing is typically goal driven.\n\nFinding bugs\nSoftware testing typically includes handling software bugs – a defect in the code that causes an undesirable result. Bugs generally slow testing progress and involve programmer assistance to debug and fix.\nNot all defects cause a failure. For example, a defect in dead code will not be considered a failure.\nA defect that does not cause failure at one point in time may lead to failure later due to environmental changes. Examples of environment change include running on new computer hardware, changes in data, and interacting with different software.\nA single defect may result in multiple failure symptoms.\n\nEnsuring requirements are satisfied\nSoftware testing may involve a Requirements gap – omission from the design for a requirement. Requirement gaps can often be non-functional requirements such as testability, scalability, maintainability, performance, and security."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 8,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 5265,
    "end_char": 6125,
    "text": "Code coverage\nA fundamental limitation of software testing is that testing under all combinations of inputs and preconditions (initial state) is not feasible, even with a simple product. \nDefects that manifest in unusual conditions are difficult to find in testing. Also, non-functional dimensions of quality (how it is supposed to be versus what it is supposed to do) – usability, scalability, performance, compatibility, and reliability – can be subjective; something that constitutes sufficient value to one person may not to another.\nAlthough testing for every possible input is not feasible, testing can use combinatorics to maximize coverage while minimizing tests.\n\nCategories\nTesting can be categorized many ways.\n\nAutomated testing\nLevels\nSoftware testing can be categorized into levels based on how much of the software system is the focus of a test."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 9,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 6127,
    "end_char": 7044,
    "text": "Unit testing\nIntegration testing\nSystem testing\nStatic, dynamic, and passive testing\nThere are many approaches to software testing. Reviews, walkthroughs, or inspections are referred to as static testing, whereas executing programmed code with a given set of test cases is referred to as dynamic testing.\nStatic testing is often implicit, like proofreading, plus when programming tools/text editors check source code structure or compilers (pre-compilers) check syntax and data flow as static program analysis. Dynamic testing takes place when the program itself is run. Dynamic testing may begin before the program is 100% complete in order to test particular sections of code and are applied to discrete functions or modules. Typical techniques for these are either using stubs/drivers or execution from a debugger environment.\nStatic testing involves verification, whereas dynamic testing also involves validation."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 10,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 6957,
    "end_char": 7402,
    "text": "Static testing involves verification, whereas dynamic testing also involves validation.\nPassive testing means verifying the system's behavior without any interaction with the software product. Contrary to active testing, testers do not provide any test data but look at system logs and traces. They mine for patterns and specific behavior in order to make some kind of decisions. This is related to offline runtime verification and log analysis."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 11,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 7404,
    "end_char": 8112,
    "text": "Exploratory\nPreset testing vs adaptive testing\nThe type of testing strategy to be performed depends on whether the tests to be applied to the IUT should be decided before the testing plan starts to be executed (preset testing) or whether each input to be applied to the IUT can be dynamically dependent on the outputs obtained during the application of the previous tests (adaptive testing).\n\nBlack/white box\nSoftware testing can often be divided into white-box and black-box. These two approaches are used to describe the point of view that the tester takes when designing test cases. A hybrid approach called grey-box that includes aspects of both boxes may also be applied to software testing methodology."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 12,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 8114,
    "end_char": 9170,
    "text": "White-box testing\nWhite-box testing (also known as clear box testing, glass box testing, transparent box testing, and structural testing) verifies the internal structures or workings of a program, as opposed to the functionality exposed to the end-user. In white-box testing, an internal perspective of the system (the source code), as well as programming skills are used to design test cases. The tester chooses inputs to exercise paths through the code and determines the appropriate outputs. This is analogous to testing nodes in a circuit, e.g., in-circuit testing (ICT).\nWhile white-box testing can be applied at the unit, integration, and system levels of the software testing process, it is usually done at the unit level. It can test paths within a unit, paths between units during integration, and between subsystems during a system–level test. Though this method of test design can uncover many errors or problems, it might not detect unimplemented parts of the specification or missing requirements.\nTechniques used in white-box testing include:"
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 13,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 9172,
    "end_char": 9974,
    "text": "API testing – testing of the application using public and private APIs (application programming interfaces)\nCode coverage – creating tests to satisfy some criteria of code coverage (for example, the test designer can create tests to cause all statements in the program to be executed at least once)\nFault injection methods – intentionally introducing faults to gauge the efficacy of testing strategies\nMutation testing methods\nStatic testing methods\nCode coverage tools can evaluate the completeness of a test suite that was created with any method, including black-box testing. This allows the software team to examine parts of a system that are rarely tested and ensures that the most important function points have been tested. Code coverage as a software metric can be reported as a percentage for:"
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 14,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 9976,
    "end_char": 10494,
    "text": "Function coverage, which reports on functions executed\nStatement coverage, which reports on the number of lines executed to complete the test\nDecision coverage, which reports on whether both the True and the False branch of a given test has been executed\n100% statement coverage ensures that all code paths or branches (in terms of control flow) are executed at least once. This is helpful in ensuring correct functionality, but not sufficient since the same code may process different inputs correctly or incorrectly."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 15,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 10496,
    "end_char": 11019,
    "text": "Black-box testing\nBlack-box testing (also known as functional testing) describes designing test cases without knowledge of the implementation, without reading the source code. The testers are only aware of what the software is supposed to do, not how it does it. Black-box testing methods include: equivalence partitioning, boundary value analysis, all-pairs testing, state transition tables, decision table testing, fuzz testing, model-based testing, use case testing, exploratory testing, and specification-based testing."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 16,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 11020,
    "end_char": 11965,
    "text": "Specification-based testing aims to test the functionality of software according to the applicable requirements. This level of testing usually requires thorough test cases to be provided to the tester, who then can simply verify that for a given input, the output value (or behavior), either \"is\" or \"is not\" the same as the expected value specified in the test case. Test cases are built around specifications and requirements, i.e., what the application is supposed to do. It uses external descriptions of the software, including specifications, requirements, and designs, to derive test cases. These tests can be functional or non-functional, though usually functional. Specification-based testing may be necessary to assure correct functionality, but it is insufficient to guard against complex or high-risk situations.\nBlack box testing can be used to any level of testing although usually not at the unit level.\nComponent interface testing"
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 17,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 11938,
    "end_char": 12949,
    "text": "Component interface testing\nComponent interface testing is a variation of black-box testing, with the focus on the data values beyond just the related actions of a subsystem component. The practice of component interface testing can be used to check the handling of data passed between various units, or subsystem components, beyond full integration testing between those units. The data being passed can be considered as \"message packets\" and the range or data types can be checked for data generated from one unit and tested for validity before being passed into another unit. One option for interface testing is to keep a separate log file of data items being passed, often with a timestamp logged to allow analysis of thousands of cases of data passed between units for days or weeks. Tests can include checking the handling of some extreme data values while other interface variables are passed as normal values. Unusual data values in an interface can help explain unexpected performance in the next unit."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 18,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 12951,
    "end_char": 13693,
    "text": "Visual testing\nThe aim of visual testing is to provide developers with the ability to examine what was happening at the point of software failure by presenting the data in such a way that the developer can easily find the information he or she requires, and the information is expressed clearly.\nAt the core of visual testing is the idea that showing someone a problem (or a test failure), rather than just describing it, greatly increases clarity and understanding. Visual testing, therefore, requires the recording of the entire test process – capturing everything that occurs on the test system in video format. Output videos are supplemented by real-time tester input via picture-in-a-picture webcam and audio commentary from microphones."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 19,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 13694,
    "end_char": 14730,
    "text": "Visual testing provides a number of advantages. The quality of communication is increased drastically because testers can show the problem (and the events leading up to it) to the developer as opposed to just describing it, and the need to replicate test failures will cease to exist in many cases. The developer will have all the evidence he or she requires of a test failure and can instead focus on the cause of the fault and how it should be fixed.\nAd hoc testing and exploratory testing are important methodologies for checking software integrity because they require less preparation time to implement, while the important bugs can be found quickly. In ad hoc testing, where testing takes place in an improvised impromptu way, the ability of the tester(s) to base testing off documented methods and then improvise variations of those tests can result in a more rigorous examination of defect fixes. However, unless strict documentation of the procedures is maintained, one of the limits of ad hoc testing is lack of repeatability."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 20,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 14732,
    "end_char": 15574,
    "text": "Grey-box testing\nGrey-box testing (American spelling: gray-box testing) involves using knowledge of internal data structures and algorithms for purposes of designing tests while executing those tests at the user, or black-box level. The tester will often have access to both \"the source code and the executable binary.\" Grey-box testing may also include reverse engineering (using dynamic code analysis) to determine, for instance, boundary values or error messages. Manipulating input data and formatting output do not qualify as grey-box, as the input and output are clearly outside of the \"black box\" that we are calling the system under test. This distinction is particularly important when conducting integration testing between two modules of code written by two different developers, where only the interfaces are exposed for the test."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 21,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 15575,
    "end_char": 16384,
    "text": "By knowing the underlying concepts of how the software works, the tester makes better-informed testing choices while testing the software from outside. Typically, a grey-box tester will be permitted to set up an isolated testing environment with activities, such as seeding a database. The tester can observe the state of the product being tested after performing certain actions such as executing SQL statements against the database and then executing queries to ensure that the expected changes have been reflected. Grey-box testing implements intelligent test scenarios based on limited information. This will particularly apply to data type handling, exception handling, and so on.\nWith the concept of grey-box testing, this \"arbitrary distinction\" between black- and white-box testing has faded somewhat."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 22,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 16386,
    "end_char": 17401,
    "text": "Installation testing\nCompatibility testing\nA common cause of software failure (real or perceived) is a lack of its compatibility with other application software, operating systems (or operating system versions, old or new), or target environments that differ greatly from the original (such as a terminal or GUI application intended to be run on the desktop now being required to become a Web application, which must render in a Web browser). For example, in the case of a lack of backward compatibility, this can occur because the programmers develop and test software only on the latest version of the target environment, which not all users may be running. This results in the unintended consequence that the latest work may not function on earlier versions of the target environment, or on older hardware that earlier versions of the target environment were capable of using. Sometimes such issues can be fixed by proactively abstracting operating system functionality into a separate program module or library."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 23,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 17403,
    "end_char": 17731,
    "text": "Smoke and sanity testing\nSanity testing determines whether it is reasonable to proceed with further testing.\nSmoke testing consists of minimal attempts to operate the software, designed to determine whether there are any basic problems that will prevent it from working at all. Such tests can be used as build verification test."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 24,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 17733,
    "end_char": 18558,
    "text": "Regression testing\nRegression testing focuses on finding defects after a major code change has occurred. Specifically, it seeks to uncover software regressions, as degraded or lost features, including old bugs that have come back. Such regressions occur whenever software functionality that was previously working correctly, stops working as intended. Typically, regressions occur as an unintended consequence of program changes, when the newly developed part of the software collides with the previously existing code. Regression testing is typically the largest test effort in commercial software development, due to checking numerous details in prior software features, and even new software can be developed while using some old test cases to test parts of the new design to ensure prior functionality is still supported."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 25,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 18559,
    "end_char": 19030,
    "text": "Common methods of regression testing include re-running previous sets of test cases and checking whether previously fixed faults have re-emerged. The depth of testing depends on the phase in the release process and the risk of the added features. They can either be complete, for changes added late in the release or deemed to be risky, or be very shallow, consisting of positive tests on each feature, if the changes are early in the release or deemed to be of low risk."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 26,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 19032,
    "end_char": 19408,
    "text": "Acceptance testing\nAcceptance testing is system-level testing to ensure the software meets customer expectations.\nAcceptance testing may be performed as part of the hand-off process between any two phases of development.\nTests are frequently grouped into these levels by where they are performed in the software development process, or by the level of specificity of the test."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 27,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 19410,
    "end_char": 20278,
    "text": "User acceptance testing (UAT)\nOperational acceptance testing (OAT)\nContractual and regulatory acceptance testing\nAlpha and beta testing\nSometimes, UAT is performed by the customer, in their environment and on their own hardware.\nOAT is used to conduct operational readiness (pre-release) of a product, service or system as part of a quality management system. OAT is a common type of non-functional software testing, used mainly in software development and software maintenance projects. This type of testing focuses on the operational readiness of the system to be supported, or to become part of the production environment. Hence, it is also known as operational readiness testing (ORT) or operations readiness and assurance (OR&A) testing. Functional testing within OAT is limited to those tests that are required to verify the non-functional aspects of the system."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 28,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 20279,
    "end_char": 20950,
    "text": "In addition, the software testing should ensure that the portability of the system, as well as working as expected, does not also damage or partially corrupt its operating environment or cause other processes within that environment to become inoperative.\nContractual acceptance testing is performed based on the contract's acceptance criteria defined during the agreement of the contract, while regulatory acceptance testing is performed based on the relevant regulations to the software product. Both of these two tests can be performed by users or independent testers. Regulation acceptance testing sometimes involves the regulatory agencies auditing the test results."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 29,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 20952,
    "end_char": 21841,
    "text": "Alpha testing\nAlpha testing is simulated or actual operational testing by potential users/customers or an independent test team at the developers' site. Alpha testing is often employed for off-the-shelf software as a form of internal acceptance testing before the software goes to beta testing.\n\nBeta testing\nBeta testing comes after alpha testing and can be considered a form of external user acceptance testing. Versions of the software, known as beta versions, are released to a limited audience outside of the programming team known as beta testers. The software is released to groups of people so that further testing can ensure the product has few faults or bugs. Beta versions can be made available to the open public to increase the feedback field to a maximal number of future users and to deliver value earlier, for an extended or even indefinite period of time (perpetual beta)."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 30,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 21843,
    "end_char": 22726,
    "text": "Functional vs non-functional testing\nFunctional testing refers to activities that verify a specific action or function of the code. These are usually found in the code requirements documentation, although some development methodologies work from use cases or user stories. Functional tests tend to answer the question of \"can the user do this\" or \"does this particular feature work.\"\nNon-functional testing refers to aspects of the software that may not be related to a specific function or user action, such as scalability or other performance, behavior under certain constraints, or security. Testing will determine the breaking point, the point at which extremes of scalability or performance leads to unstable execution. Non-functional requirements tend to be those that reflect the quality of the product, particularly in the context of the suitability perspective of its users."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 31,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 22728,
    "end_char": 23793,
    "text": "Continuous testing\nContinuous testing is the process of executing automated tests as part of the software delivery pipeline to obtain immediate feedback on the business risks associated with a software release candidate. Continuous testing includes the validation of both functional requirements and non-functional requirements; the scope of testing extends from validating bottom-up requirements or user stories to assessing the system requirements associated with overarching business goals.\n\nDestructive testing\nDestructive testing attempts to cause the software or a sub-system to fail. It verifies that the software functions properly even when it receives invalid or unexpected inputs, thereby establishing the robustness of input validation and error-management routines. Software fault injection, in the form of fuzzing, is an example of failure testing. Various commercial non-functional testing tools are linked from the software fault injection page; there are also numerous open-source and free software tools available that perform destructive testing."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 32,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 23795,
    "end_char": 24882,
    "text": "Software performance testing\nPerformance testing is generally executed to determine how a system or sub-system performs in terms of responsiveness and stability under a particular workload. It can also serve to investigate, measure, validate or verify other quality attributes of the system, such as scalability, reliability and resource usage.\nLoad testing is primarily concerned with testing that the system can continue to operate under a specific load, whether that be large quantities of data or a large number of users. This is generally referred to as software scalability. The related load testing activity of when performed as a non-functional activity is often referred to as endurance testing. Volume testing is a way to test software functions even when certain components (for example a file or database) increase radically in size. Stress testing is a way to test reliability under unexpected or rare workloads. Stability testing (often referred to as load or endurance testing) checks to see if the software can continuously function well in or above an acceptable period."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 33,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 24883,
    "end_char": 25206,
    "text": "There is little agreement on what the specific goals of performance testing are. The terms load testing, performance testing, scalability testing, and volume testing, are often used interchangeably.\nReal-time software systems have strict timing constraints. To test if timing constraints are met, real-time testing is used."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 34,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 25208,
    "end_char": 26160,
    "text": "Usability testing\nUsability testing is to check if the user interface is easy to use and understand. It is concerned mainly with the use of the application. This is not a kind of testing that can be automated; actual human users are needed, being monitored by skilled UI designers. Usability testing can use structured models to check how well an interface works. The Stanton, Theofanos, and Joshi (2015) model looks at user experience, and the Al-Sharafat and Qadoumi (2016) model is for expert evaluation, helping to assess usability in digital applications.\n\nAccessibility testing\nAccessibility testing is done to ensure that the software is accessible to persons with disabilities. Some of the common web accessibility tests are\n\nEnsuring that the color contrast between the font and the background color is appropriate\nFont Size\nAlternate Texts for multimedia content\nAbility to use the system using the computer keyboard in addition to the mouse."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 35,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 25942,
    "end_char": 26834,
    "text": "Ensuring that the color contrast between the font and the background color is appropriate\nFont Size\nAlternate Texts for multimedia content\nAbility to use the system using the computer keyboard in addition to the mouse.\n\nCommon standards for compliance\nAmericans with Disabilities Act of 1990\nSection 508 Amendment to the Rehabilitation Act of 1973\nWeb Accessibility Initiative (WAI) of the World Wide Web Consortium (W3C)\n\nSecurity testing\nSecurity testing is essential for software that processes confidential data to prevent system intrusion by hackers.\nThe International Organization for Standardization (ISO) defines this as a \"type of testing conducted to evaluate the degree to which a test item, and associated data and information, are protected so that unauthorised persons or systems cannot use, read or modify them, and authorized persons or systems are not denied access to them.\""
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 36,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 26836,
    "end_char": 27472,
    "text": "Internationalization and localization\nTesting for internationalization and localization validates that the software can be used with different languages and geographic regions. The process of pseudolocalization is used to test the ability of an application to be translated to another language, and make it easier to identify when the localization process may introduce new bugs into the product.\nGlobalization testing verifies that the software is adapted for a new culture, such as different currencies or time zones.\nActual translation to human languages must be tested, too. Possible localization and globalization failures include:"
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 37,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 27474,
    "end_char": 28448,
    "text": "Some messages may be untranslated.\nSoftware is often localized by translating a list of strings out of context, and the translator may choose the wrong translation for an ambiguous source string.\nTechnical terminology may become inconsistent, if the project is translated by several people without proper coordination or if the translator is imprudent.\nLiteral word-for-word translations may sound inappropriate, artificial or too technical in the target language.\nUntranslated messages in the original language may be hard coded in the source code, and thus untranslatable.\nSome messages may be created automatically at run time and the resulting string may be ungrammatical, functionally incorrect, misleading or confusing.\nSoftware may use a keyboard shortcut that has no function on the source language's keyboard layout, but is used for typing characters in the layout of the target language.\nSoftware may lack support for the character encoding of the target language."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 38,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 28372,
    "end_char": 29103,
    "text": "Software may lack support for the character encoding of the target language.\nFonts and font sizes that are appropriate in the source language may be inappropriate in the target language; for example, CJK characters may become unreadable if the font is too small.\nA string in the target language may be longer than the software can handle. This may make the string partly invisible to the user or cause the software to crash or malfunction.\nSoftware may lack proper support for reading or writing bi-directional text.\nSoftware may display images with text that was not localized.\nLocalized operating systems may have differently named system configuration files and environment variables and different formats for date and currency."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 39,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 29105,
    "end_char": 29986,
    "text": "Development testing\nDevelopment testing is a software development process that involves the synchronized application of a broad spectrum of defect prevention and detection strategies in order to reduce software development risks, time, and costs. It is performed by the software developer or engineer during the construction phase of the software development lifecycle. Development testing aims to eliminate construction errors before code is promoted to other testing; this strategy is intended to increase the quality of the resulting software as well as the efficiency of the overall development process.\nDepending on the organization's expectations for software development, development testing might include static code analysis, data flow analysis, metrics analysis, peer code reviews, unit testing, code coverage analysis, traceability, and other software testing practices."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 40,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 29988,
    "end_char": 30932,
    "text": "A/B testing\nA/B testing is a method of running a controlled experiment to determine if a proposed change is more effective than the current approach. Customers are routed to either a current version (control) of a feature, or to a modified version (treatment) and data is collected to determine which version is better at achieving the desired outcome.\n\nConcurrent testing\nConcurrent or concurrency testing assesses the behaviour and performance of software and systems that use concurrent computing, generally under normal usage conditions. Typical problems this type of testing will expose are deadlocks, race conditions and problems with shared memory/resource handling.\n\nConformance testing or type testing\nIn software testing, conformance testing verifies that a product performs according to its specified standards. Compilers, for instance, are extensively tested to determine whether they meet the recognized standard for that language."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 41,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 30934,
    "end_char": 31271,
    "text": "Output comparison testing\nCreating a display expected output, whether as data comparison of text or screenshots of the UI, is sometimes called snapshot testing or Golden Master Testing unlike many other forms of testing, this cannot detect failures automatically and instead requires that a human evaluate the output for inconsistencies."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 42,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 31273,
    "end_char": 32269,
    "text": "Property testing\nProperty testing is a testing technique where, instead of asserting that specific inputs produce specific expected outputs, the practitioner randomly generates many inputs, runs the program on all of them, and asserts the truth of some \"property\" that should be true for every pair of input and output. For example, every output from a serialization function should be accepted by the corresponding deserialization function, and every output from a sort function should be a monotonically increasing list containing exactly the same elements as its input.\nProperty testing libraries allow the user to control the strategy by which random inputs are constructed, to ensure coverage of degenerate cases, or inputs featuring specific patterns that are needed to fully exercise aspects of the implementation under test.\nProperty testing is also sometimes known as \"generative testing\" or \"QuickCheck testing\" since it was introduced and popularized by the Haskell library QuickCheck."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 43,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 32271,
    "end_char": 33263,
    "text": "Metamorphic testing\nMetamorphic testing (MT) is a property-based software testing technique, which can be an effective approach for addressing the test oracle problem and test case generation problem. The test oracle problem is the difficulty of determining the expected outcomes of selected test cases or to determine whether the actual outputs agree with the expected outcomes.\n\nVCR testing\nVCR testing, also known as \"playback testing\" or \"record/replay\" testing, is a testing technique for increasing the reliability and speed of regression tests that involve a component that is slow or unreliable to communicate with, often a third-party API outside of the tester's control. It involves making a recording (\"cassette\") of the system's interactions with the external component, and then replaying the recorded interactions as a substitute for communicating with the external system on subsequent runs of the test.\nThe technique was popularized in web development by the Ruby library vcr."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 44,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 33265,
    "end_char": 34340,
    "text": "Teamwork\nRoles\nIn an organization, testers may be in a separate team from the rest of the software development team or they may be integrated into one team. Software testing can also be performed by non-dedicated software testers.\nIn the 1980s, the term software tester started to be used to denote a separate profession.\nNotable software testing roles and titles include: test manager, test lead, test analyst, test designer, tester, automation developer, and test administrator.\n\nProcesses\nOrganizations that develop software, perform testing differently, but there are common patterns.\n\nWaterfall development\nIn waterfall development, testing is generally performed after the code is completed, but before the product is shipped to the customer. This practice often results in the testing phase being used as a project buffer to compensate for project delays, thereby compromising the time devoted to testing.\nSome contend that the waterfall process allows for testing to start when the development project starts and to be a continuous process until the project finishes."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 45,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 34342,
    "end_char": 35367,
    "text": "Agile development\nAgile software development commonly involves testing while the code is being written and organizing teams with both programmers and testers and with team members performing both programming and testing.\nOne agile practice, test-driven software development (TDD), is a way of unit testing such that unit-level testing is performed while writing the product code. Test code is updated as new features are added and failure conditions are discovered (bugs fixed). Commonly, the unit test code is maintained with the project code, integrated in the build process, and run on each build and as part of regression testing. Goals of this continuous integration is to support development and reduce defects.\nEven in organizations that separate teams by programming and testing functions, many often have the programmers perform unit testing.\n\nSample process\nThe sample below is common for waterfall development. The same activities are commonly found in other development models, but might be described differently."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 46,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 35369,
    "end_char": 36251,
    "text": "Requirements analysis: testing should begin in the requirements phase of the software development life cycle. During the design phase, testers work to determine what aspects of a design are testable and with what parameters those tests work.\nTest planning: test strategy, test plan, testbed creation. Since many activities will be carried out during testing, a plan is needed.\nTest development: test procedures, test scenarios, test cases, test datasets, test scripts to use in testing software.\nTest execution: testers execute the software based on the plans and test documents then report any errors found to the development team. This part could be complex when running tests with a lack of programming knowledge.\nTest reporting: once testing is completed, testers generate metrics and make final reports on their test effort and whether the software tested is ready for release."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 47,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 36086,
    "end_char": 37123,
    "text": "Test reporting: once testing is completed, testers generate metrics and make final reports on their test effort and whether the software tested is ready for release.\nTest result analysis: or defect analysis, is done by the development team usually along with the client, in order to decide what defects should be assigned, fixed, rejected (i.e. found software working properly) or deferred to be dealt with later.\nDefect retesting: once a defect has been dealt with by the development team, it is retested by the testing team.\nRegression testing: it is common to have a small test program built of a subset of tests, for each integration of new, modified, or fixed software, in order to ensure that the latest delivery has not ruined anything and that the software product as a whole is still working correctly.\nTest closure: once the test meets the exit criteria, the activities such as capturing the key outputs, lessons learned, results, logs, documents related to the project are archived and used as a reference for future projects."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 48,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 37125,
    "end_char": 38075,
    "text": "Quality\nSoftware verification and validation\nSoftware testing is used in association with verification and validation:\n\nVerification: Have we built the software right? (i.e., does it implement the requirements).\nValidation: Have we built the right software? (i.e., do the deliverables satisfy the customer).\nThe terms verification and validation are commonly used interchangeably in the industry; it is also common to see these two terms defined with contradictory definitions. According to the IEEE Standard Glossary of Software Engineering Terminology:\n\nVerification is the process of evaluating a system or component to determine whether the products of a given development phase satisfy the conditions imposed at the start of that phase.\nValidation is the process of evaluating a system or component during or at the end of the development process to determine whether it satisfies specified requirements.\nAnd, according to the ISO 9000 standard:"
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 49,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 38077,
    "end_char": 38512,
    "text": "Verification is confirmation by examination and through provision of objective evidence that specified requirements have been fulfilled.\nValidation is confirmation by examination and through provision of objective evidence that the requirements for a specific intended use or application have been fulfilled.\nThe contradiction is caused by the use of the concepts of requirements and specified requirements but with different meanings."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 50,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 38386,
    "end_char": 39188,
    "text": "The contradiction is caused by the use of the concepts of requirements and specified requirements but with different meanings.\nIn the case of IEEE standards, the specified requirements, mentioned in the definition of validation, are the set of problems, needs and wants of the stakeholders that the software must solve and satisfy. Such requirements are documented in a Software Requirements Specification (SRS). And, the products mentioned in the definition of verification, are the output artifacts of every phase of the software development process. These products are, in fact, specifications such as Architectural Design Specification, Detailed Design Specification, etc. The SRS is also a specification, but it cannot be verified (at least not in the sense used here, more on this subject below)."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 51,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 39189,
    "end_char": 39895,
    "text": "But, for the ISO 9000, the specified requirements are the set of specifications, as just mentioned above, that must be verified. A specification, as previously explained, is the product of a software development process phase that receives another specification as input. A specification is verified successfully when it correctly implements its input specification. All the specifications can be verified except the SRS because it is the first one (it can be validated, though). Examples: The Design Specification must implement the SRS; and, the Construction phase artifacts must implement the Design Specification.\nSo, when these words are defined in common terms, the apparent contradiction disappears."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 52,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 39807,
    "end_char": 40778,
    "text": "So, when these words are defined in common terms, the apparent contradiction disappears.\nBoth the SRS and the software must be validated. The SRS can be validated statically by consulting with the stakeholders. Nevertheless, running some partial implementation of the software or a prototype of any kind (dynamic testing) and obtaining positive feedback from them, can further increase the certainty that the SRS is correctly formulated. On the other hand, the software, as a final and running product (not its artifacts and documents, including the source code) must be validated dynamically with the stakeholders by executing the software and having them to try it.\nSome might argue that, for SRS, the input is the words of stakeholders and, therefore, SRS validation is the same as SRS verification. Thinking this way is not advisable as it only causes more confusion. It is better to think of verification as a process involving a formal and technical input document."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 53,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 40780,
    "end_char": 41836,
    "text": "Software quality assurance\nIn some organizations, software testing is part of a software quality assurance (SQA) process. In SQA, software process specialists and auditors are concerned with the software development process rather than just the artifacts such as documentation, code and systems. They examine and change the software engineering process itself to reduce the number of faults that end up in the delivered software: the so-called defect rate. What constitutes an acceptable defect rate depends on the nature of the software; a flight simulator video game would have much higher defect tolerance than software for an actual airplane. Although there are close links with SQA, testing departments often exist independently, and there may be no SQA function in some companies.\nSoftware testing is an activity to investigate software under test in order to provide quality-related information to stakeholders. By contrast, QA (quality assurance) is the implementation of policies and procedures intended to prevent defects from reaching customers."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 54,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 41838,
    "end_char": 42414,
    "text": "Measures\nQuality measures include such topics as correctness, completeness, security and ISO/IEC 9126 requirements such as capability, reliability, efficiency, portability, maintainability, compatibility, and usability.\nThere are a number of frequently used software metrics, or measures, which are used to assist in determining the state of the software or the adequacy of the testing.\n\nArtifacts\nA software testing process can produce several artifacts. The actual artifacts produced are a factor of the software development model used, stakeholder and organisational needs."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 55,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 42226,
    "end_char": 43107,
    "text": "Artifacts\nA software testing process can produce several artifacts. The actual artifacts produced are a factor of the software development model used, stakeholder and organisational needs.\n\nTest plan\nA test plan is a document detailing the approach that will be taken for intended test activities. The plan may include aspects such as objectives, scope, processes and procedures, personnel requirements, and contingency plans. The test plan could come in the form of a single plan that includes all test types (like an acceptance or system test plan) and planning considerations, or it may be issued as a master test plan that provides an overview of more than one detailed test plan (a plan of a plan). A test plan can be, in some cases, part of a wide \"test strategy\" which documents overall testing approaches, which may itself be a master test plan or even a separate artifact."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 56,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 43109,
    "end_char": 43138,
    "text": "Traceability matrix\nTest case"
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 57,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 43139,
    "end_char": 44238,
    "text": "A test case normally consists of a unique identifier, requirement references from a design specification, preconditions, events, a series of steps (also known as actions) to follow, input, output, expected result, and the actual result. Clinically defined, a test case is an input and an expected result. This can be as terse as \"for condition x your derived result is y\", although normally test cases describe in more detail the input scenario and what results might be expected. It can occasionally be a series of steps (but often steps are contained in a separate test procedure that can be exercised against multiple test cases, as a matter of economy) but with one expected result or expected outcome. The optional fields are a test case ID, test step, or order of execution number, related requirement(s), depth, test category, author, and check boxes for whether the test is automatable and has been automated. Larger test cases may also contain prerequisite states or steps, and descriptions. A test case should also contain a place for the actual result. These steps can be stored in a word"
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 58,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 44021,
    "end_char": 44537,
    "text": "automatable and has been automated. Larger test cases may also contain prerequisite states or steps, and descriptions. A test case should also contain a place for the actual result. These steps can be stored in a word processor document, spreadsheet, database, or other common repositories. In a database system, you may also be able to see past test results, who generated the results, and what system configuration was used to generate those results. These past results would usually be stored in a separate table."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 59,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 44539,
    "end_char": 45559,
    "text": "Test script\nA test script is a procedure or programming code that replicates user actions. Initially, the term was derived from the product of work created by automated regression test tools. A test case will be a baseline to create test scripts using a tool or a program.\n\nTest suite\nTest fixture or test data\nIn most cases, multiple sets of values or data are used to test the same functionality of a particular feature. All the test values and changeable environmental components are collected in separate files and stored as test data. It is also useful to provide this data to the client and with the product or a project. There are techniques to generate Test data.\n\nTest harness\nThe software, tools, samples of data input and output, and configurations are all referred to collectively as a test harness.\n\nTest run\nA test run is a collection of test cases or test suites that the user is executing and comparing the expected with the actual results. Once complete, a report or all executed tests may be generated."
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 60,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 45352,
    "end_char": 45900,
    "text": "Test run\nA test run is a collection of test cases or test suites that the user is executing and comparing the expected with the actual results. Once complete, a report or all executed tests may be generated.\n\nCertifications\nSeveral certification programs exist to support the professional aspirations of software testers and quality assurance specialists. A few practitioners argue that the testing field is not ready for certification, as mentioned in the controversy section.\n\nControversy\nSome of the major software testing controversies include:"
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 61,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 45902,
    "end_char": 46875,
    "text": "Agile vs. traditional\nShould testers learn to work under conditions of uncertainty and constant change or should they aim at process \"maturity\"? The agile testing movement has received growing popularity since the early 2000s mainly in commercial circles, whereas government and military software providers use this methodology but also the traditional test-last models (e.g., in the Waterfall model).\nManual vs. automated testing\nSome writers believe that test automation is so expensive relative to its value that it should be used sparingly. The test automation then can be considered as a way to capture and implement the requirements. As a general rule, the larger the system and the greater the complexity, the greater the ROI in test automation. Also, the investment in tools and expertise can be amortized over multiple projects with the right level of knowledge sharing within an organization.\nIs the existence of the ISO 29119 software testing standard justified?"
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 62,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 46805,
    "end_char": 47795,
    "text": "Is the existence of the ISO 29119 software testing standard justified?\nSignificant opposition has formed out of the ranks of the context-driven school of software testing about the ISO 29119 standard. Professional testing associations, such as the International Society for Software Testing, have attempted to have the standard withdrawn.\nSome practitioners declare that the testing field is not ready for certification\n No certification now offered actually requires the applicant to show their ability to test software. No certification is based on a widely accepted body of knowledge. Certification itself cannot measure an individual's productivity, their skill, or practical knowledge, and cannot guarantee their competence, or professionalism as a tester.\nStudies used to show the relative expense of fixing defects\nThere are opposing views on the applicability of studies used to show the relative expense of fixing defects depending on their introduction and detection. For example:"
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 63,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 47797,
    "end_char": 48403,
    "text": "It is commonly believed that the earlier a defect is found, the cheaper it is to fix it. The following table shows the cost of fixing the defect depending on the stage it was found. For example, if a problem in the requirements is found only post-release, then it would cost 10–100 times more to fix than if it had already been found by the requirements review. With the advent of modern continuous deployment practices and cloud-based services, the cost of re-deployment and maintenance may lessen over time.\n\nThe data from which this table is extrapolated is scant. Laurent Bossavit says in his analysis:"
  },
  {
    "doc_id": "Software_testing",
    "chunk_id": 64,
    "source_path": "/Users/samemmanuel/Documents/MS/Course Work/DL/Project 3/LangChain-Project/Datasets/data/Software_testing.txt",
    "start_char": 48308,
    "end_char": 49322,
    "text": "The data from which this table is extrapolated is scant. Laurent Bossavit says in his analysis:\n\nThe \"smaller projects\" curve turns out to be from only two teams of first-year students, a sample size so small that extrapolating to \"smaller projects in general\" is totally indefensible. The GTE study does not explain its data, other than to say it came from two projects, one large and one small. The paper cited for the Bell Labs \"Safeguard\" project specifically disclaims having collected the fine-grained data that Boehm's data points suggest. The IBM study (Fagan's paper) contains claims that seem to contradict Boehm's graph and no numerical results that clearly correspond to his data points.\n\nBoehm doesn't even cite a paper for the TRW data, except when writing for \"Making Software\" in 2010, and there he cited the original 1976 article. There exists a large study conducted at TRW at the right time for Boehm to cite it, but that paper doesn't contain the sort of data that would support Boehm's claims."
  }
]